{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>      Read Paper \u2197         View on GitHub    </p> <p>Scarf (short for Self-Contained Application Refactoring) benchmark is a suite of Java applications across frameworks: Jakarta EE, Quarkus, and Spring for evaluating agentic transformation between the frameworks. This suite enables systematic assessment of AI agents' ability to migrate enterprise Java applications while preserving functionality, idiomatic patterns, and architectural integrity across different runtime environments.</p> <p>The benchmark includes comprehensive examples ranging from focused layer-specific demonstrations to complete production-grade applications, each with verified implementations across all supported frameworks.</p>"},{"location":"#getting-started-with-the-scarf-benchmark","title":"Getting Started with the Scarf Benchmark","text":"<p>Get started with using Scarf benchmark:</p> <ul> <li> <p>  Quickstart</p> <p>Run through an example to quickly set up CLDK and perform multilingual code analysis.</p> </li> <li> <p>  Installing <code>cldk</code></p> <p>Install and initialize the <code>cldk</code> Python package to start analyzing your codebases.</p> </li> </ul>"},{"location":"#benchmark-applications","title":"Benchmark Applications","text":"<p>This benchmark contains self-contained applications demonstrating core Java EE functionalities and their framework-specific implementations. Each example has been manually converted and verified across all target frameworks, with smoke tests included to verify application behavior after transformation.</p> <p>The benchmark includes two types of examples:</p>"},{"location":"#focused-examples","title":"Focused Examples","text":"<p>Application examples organized per layer, where each example demonstrates a specific technology within that layer (e.g., persistence, presentation, integration).</p> <ul> <li> <p>  Business Domain Layer</p> <p>Core business logic implementations using Enterprise JavaBeans (EJBs). Demonstrates stateful, stateless, and singleton session beans for shopping carts, currency conversion, hit counters, web services, and standalone EJB usage.</p> </li> <li> <p>  Dependency Injection Layer</p> <p>CDI and dependency injection patterns including custom qualifiers, interceptors, decorators, producer methods, event observers, and alternative implementations for conditional bean selection.</p> </li> <li> <p>  Infrastructure Layer</p> <p>Enterprise features including managed executors for concurrency, asynchronous EJB methods, interceptors for cross-cutting concerns, and timer services for scheduled task execution.</p> </li> <li> <p>  Integration Layer</p> <p>Integration technologies featuring Jakarta Batch processing, JMS messaging patterns, message-driven beans, JAX-WS web services, and Java Connector Architecture for enterprise system integration.</p> </li> <li> <p>  Persistence Layer</p> <p>Data persistence patterns using JPA entities with CRUD operations, complex entity relationships, composite keys, inheritance strategies, and JPQL queries for database interactions.</p> </li> <li> <p>  Presentation Layer</p> <p>Web tier implementations including servlets, JAX-RS REST APIs, WebSocket endpoints, server-sent events, file uploads, filters, listeners, and real-time communication patterns.</p> </li> <li> <p>  Security Layer</p> <p>Authentication and authorization patterns featuring Jakarta Security identity stores, form-based and basic authentication, EJB security, role-based access control, and password hashing.</p> </li> </ul>"},{"location":"#whole-applications","title":"Whole Applications","text":"<p>Complete, functioning applications that demonstrate the coordination and interaction between multiple layers.</p> <ul> <li> <p>  CargoTracker</p> <p>Domain-Driven Design cargo shipping tracker with Jakarta Faces, CDI, Enterprise Beans, JPA, REST, Batch, and JMS. Showcases aggregates, repositories, and domain events following Eric Evans' DDD patterns.</p> </li> <li> <p>  Coffee Shop</p> <p>Event-driven microservices with Orders, Barista, and Kitchen services via Kafka. Demonstrates MicroProfile stack, reactive messaging, distributed transactions, and eventual consistency.</p> </li> <li> <p>  DayTrader</p> <p>High-performance stock trading benchmark with stateless session beans, JPA optimistic locking, transaction management, and connection pooling. Used for measuring server performance.</p> </li> <li> <p>  PetClinic</p> <p>Veterinary clinic management with Jakarta Faces (PrimeFaces), complex JPA relationships, CDI, and Bean Validation. Complete workflows for owners, pets, visits, and veterinarians.</p> </li> <li> <p>  RealWorld</p> <p>Medium.com clone with MicroProfile JWT, JAX-RS REST API, article management, comments, favorites, tags, and user following. Includes Testcontainers integration tests.</p> </li> </ul>"},{"location":"#roadmap","title":"Roadmap","text":"<p>ScarfBench is actively maintained and continuously evolving to support the research community. We are committed to expanding the benchmark's capabilities and improving its utility for evaluating AI-driven application transformation. Here's what's coming:</p> <ul> <li> <p> Comprehensive Smoke Tests</p> <p>We are developing an extensive suite of automated smoke tests to validate functional equivalence across framework migrations. These tests will ensure that transformed applications maintain their original behavior, catching subtle regressions and framework-specific issues that may arise during migration.</p> </li> <li> <p> Dynamic Leaderboard</p> <p>A live leaderboard will track and compare the performance of different AI agents and transformation tools across the benchmark suite. This will provide transparent, reproducible metrics for the research community and help identify best practices in automated application migration.</p> </li> <li> <p> Rich Taxonomy of Errors</p> <p>We are building a comprehensive taxonomy that categorizes transformation errors, anti-patterns, and common pitfalls. This taxonomy will help researchers understand where current approaches struggle and guide development of more robust transformation strategies.</p> </li> </ul> <p>ScarfBench will continue to receive regular updates with new applications, enhanced documentation, and improved tooling. We welcome community contributions and feedback to make this benchmark more valuable for advancing the state of automated application transformation.</p>"},{"location":"#contact","title":"Contact","text":"<p>For any questions, feedback, or suggestions, please contact the authors:</p> Name Email Rahul Krishna i.m.ralk@gmail.com Raju Pavuluri pavuluri@us.ibm.com"},{"location":"benchmark/","title":"Benchmark","text":"<p>Scarf is a benchmark suite for evaluating agentic transformation of Java applications across frameworks: Jakarta EE, Quarkus, and Spring. This suite enables systematic assessment of AI agents' ability to migrate enterprise Java applications while preserving functionality, idiomatic patterns, and architectural integrity across different runtime environments.</p> <p>This benchmark contains self-contained applications demonstrating core Java EE functionalities and their framework-specific implementations. Each example has been manually converted and verified across all target frameworks, with smoke tests included to verify application behavior after transformation.</p> <p>The benchmark includes two types of examples:</p> <ol> <li>Focused examples - Application examples organized per layer, where each example demonstrates a specific technology within that layer (e.g., persistence, presentation, integration).</li> <li>Whole applications - Complete, functioning applications that demonstrate the coordination and interaction between multiple layers.</li> </ol>"},{"location":"benchmark/#focused-examples","title":"Focused Examples","text":"<p>Application examples organized per layer, where each example demonstrates a specific technology within that layer (e.g., persistence, presentation, integration).</p> <ul> <li> <p>  Business Domain Layer</p> <p>Core business logic implementations using Enterprise JavaBeans (EJBs). Demonstrates stateful, stateless, and singleton session beans for shopping carts, currency conversion, hit counters, web services, and standalone EJB usage.</p> </li> <li> <p>  Dependency Injection Layer</p> <p>CDI and dependency injection patterns including custom qualifiers, interceptors, decorators, producer methods, event observers, and alternative implementations for conditional bean selection.</p> </li> <li> <p>  Infrastructure Layer</p> <p>Enterprise features including managed executors for concurrency, asynchronous EJB methods, interceptors for cross-cutting concerns, and timer services for scheduled task execution.</p> </li> <li> <p>  Integration Layer</p> <p>Integration technologies featuring Jakarta Batch processing, JMS messaging patterns, message-driven beans, JAX-WS web services, and Java Connector Architecture for enterprise system integration.</p> </li> <li> <p>  Persistence Layer</p> <p>Data persistence patterns using JPA entities with CRUD operations, complex entity relationships, composite keys, inheritance strategies, and JPQL queries for database interactions.</p> </li> <li> <p>  Presentation Layer</p> <p>Web tier implementations including servlets, JAX-RS REST APIs, WebSocket endpoints, server-sent events, file uploads, filters, listeners, and real-time communication patterns.</p> </li> <li> <p>  Security Layer</p> <p>Authentication and authorization patterns featuring Jakarta Security identity stores, form-based and basic authentication, EJB security, role-based access control, and password hashing.</p> </li> </ul>"},{"location":"benchmark/#whole-applications","title":"Whole Applications","text":"<p>Complete, functioning applications that demonstrate the coordination and interaction between multiple layers.</p> <ul> <li> <p>  CargoTracker</p> <p>Domain-Driven Design cargo shipping tracker with Jakarta Faces, CDI, Enterprise Beans, JPA, REST, Batch, and JMS. Showcases aggregates, repositories, and domain events following Eric Evans' DDD patterns.</p> </li> <li> <p>  Coffee Shop</p> <p>Event-driven microservices with Orders, Barista, and Kitchen services via Kafka. Demonstrates MicroProfile stack, reactive messaging, distributed transactions, and eventual consistency.</p> </li> <li> <p>  DayTrader</p> <p>High-performance stock trading benchmark with stateless session beans, JPA optimistic locking, transaction management, and connection pooling. Used for measuring server performance.</p> </li> <li> <p>  PetClinic</p> <p>Veterinary clinic management with Jakarta Faces (PrimeFaces), complex JPA relationships, CDI, and Bean Validation. Complete workflows for owners, pets, visits, and veterinarians.</p> </li> <li> <p>  RealWorld</p> <p>Medium.com clone with MicroProfile JWT, JAX-RS REST API, article management, comments, favorites, tags, and user following. Includes Testcontainers integration tests.</p> </li> </ul>"},{"location":"business_domain/","title":":cldk-briefcase-16: Business Domain","text":"<p>Core business logic implementations using Enterprise JavaBeans (EJBs). These examples demonstrate different EJB types\u2014stateful, stateless, and singleton session beans\u2014for common enterprise patterns like shopping carts, currency conversion, hit counters, web services, and standalone EJB usage.</p>"},{"location":"business_domain/#examples","title":"Examples","text":"<ul> <li>cart - Stateful session bean with shopping cart lifecycle management and <code>@Remove</code> methods</li> <li>converter - Stateless session bean demonstrating currency conversion business logic</li> <li>counter - Singleton session bean with shared state for tracking web page hits</li> <li>helloservice - JAX-WS web service implemented as a stateless session bean</li> <li>standalone - Stateless session bean for standalone EJB container usage</li> </ul>"},{"location":"cargotracker/","title":"CargoTracker","text":"<p>Domain-Driven Design (DDD) cargo shipping tracker demonstrating Jakarta Faces, CDI, Enterprise Beans, JPA, REST, Batch, JSON Binding, Bean Validation, and JMS.</p>"},{"location":"cargotracker/#overview","title":"Overview","text":"<p>CargoTracker showcases end-to-end application architecture with multiple interfaces (web UI, REST API, file scanning) and complex domain modeling including aggregates, repositories, and domain events. This application implements the cargo tracking example from Eric Evans' seminal Domain-Driven Design book.</p>"},{"location":"cargotracker/#key-technologies","title":"Key Technologies","text":"<ul> <li>Jakarta Faces - Web UI layer</li> <li>CDI - Dependency injection</li> <li>Enterprise Beans - Business logic</li> <li>JPA - Data persistence</li> <li>REST - API integration</li> <li>Batch - File processing</li> <li>JSON Binding - Data serialization</li> <li>Bean Validation - Input validation</li> <li>JMS - Asynchronous messaging</li> </ul>"},{"location":"cargotracker/#architecture-highlights","title":"Architecture Highlights","text":"<ul> <li>Domain-Driven Design patterns (Aggregates, Entities, Value Objects)</li> <li>Repository pattern for data access</li> <li>Domain events for decoupled communication</li> <li>Multiple presentation interfaces (Web UI, REST API)</li> <li>Batch processing for file-based imports</li> </ul>"},{"location":"citation/","title":"Citation","text":"BibTeX APA MLA <pre>[Placeholder: BibTeX citation]</pre> Copy"},{"location":"coffee_shop/","title":"Coffee Shop","text":"<p>Microservices architecture with Orders, Barista, and Kitchen services communicating via Apache Kafka.</p>"},{"location":"coffee_shop/#overview","title":"Overview","text":"<p>Coffee Shop demonstrates event-driven microservices architecture with asynchronous inter-service communication and eventual consistency. The application models a coffee shop ordering system with separate services handling orders, beverage preparation, and food preparation.</p>"},{"location":"coffee_shop/#key-technologies","title":"Key Technologies","text":"<ul> <li>MicroProfile Config - External configuration</li> <li>MicroProfile Health - Service health checks</li> <li>MicroProfile OpenAPI - API documentation</li> <li>MicroProfile Metrics - Application monitoring</li> <li>JPA with PostgreSQL - Data persistence</li> <li>JAX-RS - REST API endpoints</li> <li>Apache Kafka - Event streaming</li> <li>Reactive Messaging - Async message handling</li> </ul>"},{"location":"coffee_shop/#architecture-highlights","title":"Architecture Highlights","text":"<ul> <li>Microservices architecture with service decomposition</li> <li>Event-driven communication via Kafka topics</li> <li>Distributed transaction coordination</li> <li>Eventual consistency patterns</li> <li>Service health monitoring and metrics</li> <li>RESTful API design</li> </ul>"},{"location":"daytrader/","title":"DayTrader","text":"<p>Online stock trading benchmark application demonstrating real-world Java EE workload patterns.</p>"},{"location":"daytrader/#overview","title":"Overview","text":"<p>DayTrader is a performance benchmark application that implements a complete online stock trading system. It includes user authentication, portfolio management, stock quote lookup, and buy/sell transaction processing. This application is commonly used for measuring application server performance and scalability.</p>"},{"location":"daytrader/#key-technologies","title":"Key Technologies","text":"<ul> <li>Stateless Session Beans - Business logic tier</li> <li>JPA - Entity persistence</li> <li>Optimistic Locking - Concurrency control</li> <li>Transaction Management - ACID properties</li> <li>Connection Pooling - Resource optimization</li> <li>Web Services - SOAP and REST interfaces</li> </ul>"},{"location":"daytrader/#architecture-highlights","title":"Architecture Highlights","text":"<ul> <li>Performance-oriented design patterns</li> <li>High-concurrency transaction processing</li> <li>Database optimization with connection pooling</li> <li>Optimistic locking for concurrent data access</li> <li>Stateless architecture for horizontal scalability</li> <li>Comprehensive transaction management</li> <li>Multiple interface options (Web, SOAP, REST)</li> </ul>"},{"location":"dependency_injection/","title":":cldk-plug-16: Dependency Injection","text":"<p>CDI and dependency injection patterns including custom qualifiers, interceptors, decorators, producer methods, event observers, and alternative implementations for conditional bean selection.</p>"},{"location":"dependency_injection/#examples","title":"Examples","text":"<ul> <li>billpayment - CDI with <code>@Inject</code>, custom qualifiers, interceptors, and event observers</li> <li>decorators - CDI decorators and interceptors for cross-cutting concerns</li> <li>encoder - CDI with <code>@Alternative</code> implementations for conditional bean selection</li> <li>guessnumber - CDI with custom qualifiers, producer methods, and scope management</li> <li>producerfields - CDI producer fields for EntityManager injection and resource management</li> <li>producermethods - CDI producer methods with custom qualifiers for bean selection</li> <li>simplegreeting - Basic CDI dependency injection with <code>@Inject</code> and custom qualifiers</li> </ul>"},{"location":"infrastructure/","title":":cldk-server-16: Infrastructure","text":"<p>Enterprise features including managed executors for concurrency, asynchronous EJB methods, interceptors for cross-cutting concerns, and timer services for scheduled task execution.</p>"},{"location":"infrastructure/#examples","title":"Examples","text":"<ul> <li>concurrency-jobs - ManagedExecutorService with <code>@Resource</code> injection for concurrent task execution</li> <li>concurrency-taskcreator - ManagedExecutorService and ManagedScheduledExecutorService for async tasks with WebSocket updates</li> <li>ejb-async - Asynchronous EJB methods with Future return types <li>ejb-interceptor - EJB interceptors for method-level cross-cutting concerns</li> <li>ejb-timersession - EJB timer service with <code>@Schedule</code> and <code>@Timeout</code> for scheduled tasks</li>"},{"location":"installing/","title":"Installing <code>cldk</code>","text":"<p><code>CLDK</code> is a Python SDK hosted on PyPI and can be installed using your preferred Python package manager.</p>"},{"location":"installing/#installation","title":"Installation","text":"<p>The Python SDK can be installed directly from PyPI using any Python package manager such as pip, poetry, or uv:</p> <code>pip</code><code>poetry</code><code>uv</code> <pre><code>pip install cldk\n</code></pre> <pre><code>poetry add cldk\n</code></pre> <pre><code>uv add cldk\n</code></pre>"},{"location":"installing/#programming-language-specific-dependencies","title":"Programming Language Specific Dependencies","text":"<p><code>CLDK</code> supports program analysis for multiple languages and requires additional dependencies to support specific languages. The following table lists the additional dependencies required for each language:</p> Python AnalysisJava AnalysisC/C++ AnalysisRust Installation <p>For Python analysis as well as to use the CLDK Python SDK, you will need to install the Python programming language with version 3.11 or later. We recommend using a package manager like pyenv to install and manage Python dependencies.</p> <p>For Java analysis, CLDK relies on a companion project called <code>codeanalyzer</code>. <code>codeanalyzer</code> is a java project and you will therefore need to install the Java Development Kit (JDK) with java version 11 or later.</p> <p>You can use a package manager like SDKMAN to install the JDK. First, install SDKMAN by running the following command:</p> <ul> <li> <p>To install <code>SDKMan</code>, open your terminal and enter the following command and follow the instructions to complete the installation:</p> <pre><code>curl -s \"https://get.sdkman.io\" | bash\n</code></pre> </li> <li> <p>Open a new terminal or source the SDKMan! scripts:</p> <pre><code>source \"$HOME/.sdkman/bin/sdkman-init.sh\"\n</code></pre> </li> </ul> <p>Next, install java 11 or later using SDKMAN:</p> <ul> <li> <p>You can list all available java versions with:</p> <pre><code>sdk list java | grep sem\n</code></pre> <p>You should see something like this: <pre><code>Semeru      |     | 21.0.5       | sem     |            | 21.0.5-sem\n            |     | 17.0.13      | sem     |            | 17.0.13-sem\n            |     | 11.0.25      | sem     |            | 11.0.25-sem\n            |     | 8.0.432      | sem     |            | 8.0.432-sem\n</code></pre></p> </li> <li> <p>Install Java 11 or above (we'll go with <code>11.0.25-sem</code>):</p> <pre><code>sdk install java 11.0.25-sem\n</code></pre> </li> <li> <p>Set Java 11 as the current (or default) Java version:</p> <pre><code>sdk use java 11.0.25-sem\n# If want to default to java 11 for all sessions, use the following command instead:\n# sdk default java 11.0.25-sem\n</code></pre> </li> <li> <p>Verify the installation:</p> <pre><code>java -version\n</code></pre> <p>This should output the version of the installed Java.</p> <pre><code>openjdk 11.0.25 2024-10-15\nIBM Semeru Runtime Open Edition 11.0.25.0 (build 11.0.25+9)\nEclipse OpenJ9 VM 11.0.25.0 (build openj9-0.48.0, JRE 11 Linux amd64-64-Bit Compressed References 20241107_1233 (JIT enabled, AOT enabled)\nOpenJ9   - 1d5831436e\nOMR      - d10a4d553\nJCL      - edded3f65c based on jdk-11.0.25+9)\n</code></pre> </li> </ul> <p>Finally, to enable building Java projects automatically, you will need to install the <code>maven</code> build tool. You can install <code>maven</code> using a package manager like <code>SDKMAN</code>:</p> <ul> <li> <p>Install Maven:</p> <pre><code>sdk install maven\n</code></pre> </li> <li> <p>Make sure <code>mvn</code> command is available in the <code>PATH</code>. If <code>mvn</code> is not in your path, add the following to your <code>~/.zshrc</code>, <code>~/.bashrc</code> or <code>~/.bash_profile</code> file:</p> <p><pre><code>export PATH=\"$HOME/.sdkman/candidates/maven/current/bin:$PATH\"\n</code></pre> Then, source the file to apply the changes:</p> <pre><code>source ~/.zshrc # or ~/.bashrc or ~/.bash_profile\n</code></pre> </li> <li> <p>Verify the installation:</p> <p><pre><code>mvn -version\n</code></pre> This should output the version of the installed Maven.</p> </li> </ul> <p>CLDK uses LLVM and Clang Python bindings to analyze C/C++ code. The project requires specific versions:</p> <ul> <li>libclang &gt;= 18.1.1</li> <li>clang &gt;= 17.0.6</li> </ul> <p>You can install LLVM and Clang using various package managers depending on your operating system.</p> macOSUbuntu/DebianRed Hat-based Systems (Fedora/CentOS/RHEL) <ul> <li> <p>Install LLVM 18 using Homebrew <pre><code>brew install llvm@18\n</code></pre></p> </li> <li> <p>Add LLVM to your PATH (add this to your ~/.zshrc or ~/.bash_profile) <pre><code>export PATH=\"/usr/local/opt/llvm@18/bin:$PATH\"\nexport LDFLAGS=\"-L/usr/local/opt/llvm@18/lib\"\nexport CPPFLAGS=\"-I/usr/local/opt/llvm@18/include\"\n</code></pre></p> </li> <li> <p>Verify installation <pre><code>clang --version\n</code></pre> This should output the version of the installed LLVM and Clang. <pre><code>Apple clang version 18.1.1\nTarget: x86_64-apple-darwin21.6.0\nThread model: posix\nInstalledDir: /usr/local/opt/llvm@18/bin\n</code></pre></p> </li> </ul> <ul> <li> <p>Add LLVM repository and install required packages <pre><code>wget https://apt.llvm.org/llvm.sh\nchmod +x llvm.sh\nsudo ./llvm.sh 18\nsudo apt-get install llvm-18 llvm-18-dev clang-18 libclang-18-dev\n</code></pre></p> </li> <li> <p>Create symlinks (optional but recommended) <pre><code>sudo ln -s /usr/bin/clang-18 /usr/bin/clang\nsudo ln -s /usr/bin/llvm-config-18 /usr/bin/llvm-config\n</code></pre></p> </li> <li> <p>Verify installation <pre><code>clang --version\n</code></pre> This should output the version of the installed LLVM and Clang. <pre><code>Ubuntu clang version 18.1.1\nTarget: x86_64-pc-linux-gnu\nThread model: posix\nInstalledDir: /usr/bin\n</code></pre></p> </li> </ul> <ul> <li> <p>Install LLVM 18 and development packages <pre><code># On Fedora\nsudo dnf install llvm18 llvm18-devel clang18 clang18-devel\n\n# On CentOS/RHEL (if needed)\nsudo yum install epel-release\nsudo yum install llvm18 llvm18-devel clang18 clang18-devel\n</code></pre></p> </li> <li> <p>Create symlinks (optional but recommended) <pre><code>sudo ln -s /usr/bin/clang-18 /usr/bin/clang\nsudo ln -s /usr/bin/llvm-config-18 /usr/bin/llvm-config\n</code></pre></p> </li> <li> <p>Verify installation <pre><code>clang --version\n</code></pre> This should output the version of the installed LLVM and Clang. <pre><code>clang version 18.1.8 (Fedora 18.1.8-5.fc41)\nTarget: x86_64-redhat-linux-gnu\nThread model: posix\nInstalledDir: /usr/bin\nConfiguration file: /etc/clang18/x86_64-redhat-linux-gnu-clang.cfg\n</code></pre></p> </li> </ul> <p>Rustup is the recommended tool for installing Rust and managing its toolchains. It simplifies the process of keeping Rust up to date and allows switching between different Rust versions and toolchains seamlessly.</p> <ul> <li> <p>Install Rustup Run the following command in your terminal: <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> Follow the on-screen instructions to complete the installation.</p> </li> <li> <p>Configure Your Environment Add Rust to your PATH by appending this line to your shell init script: <pre><code>source $HOME/.cargo/env\n</code></pre></p> </li> <li> <p>Verify Installation Confirm that Rust is installed correctly by checking the version: <pre><code>rustc --version\n</code></pre> Expected output (version may vary): <pre><code>rustc 1.70.0 (90c541806 2023-05-31)\n</code></pre></p> </li> </ul>"},{"location":"installing/#additional-development-tools","title":"Additional Development Tools","text":"<p>Some operating systems may require additional development tools:</p> macOSUbuntu/DebianRed Hat-based Systems (Fedora/CentOS/RHEL) <ul> <li> <p>Make sure you have the Xcode Command Line Tools installed. You can install them using the following command:</p> <pre><code>xcode-select --install\n</code></pre> </li> <li> <p>Additionally, you may need to install the following packages using Homebrew:</p> <pre><code>brew install openssl readline sqlite3 xz zlib tcl-tk libffi\n</code></pre> </li> </ul> <ul> <li> <p>Install the required development tools using the following command:</p> <pre><code>sudo apt-get install build-essential python3-dev libssl-dev zlib1g-dev \\\nlibbz2-dev libreadline-dev libsqlite3-dev curl git \\\nlibncursesw5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev\n</code></pre> </li> </ul> <ul> <li> <p>Install the required development tools using the following command:</p> <pre><code>sudo dnf group install c-development development-tools gcc make \\\npatch zlib-devel bzip2 bzip2-devel readline-devel sqlite sqlite-devel\\\nopenssl-devel tk-devel libffi-devel xz-devel\n</code></pre> </li> </ul>"},{"location":"installing/#supported-python-versions","title":"Supported Python Versions","text":"<p><code>CLDK</code> is compatible with Python versions 3.11 and later. The following table lists the supported Python versions and the corresponding <code>CLDK</code> versions:</p>  Python Version  Compatible <code>cldk</code> Versions 3.11 \u22650.4.0"},{"location":"integration/","title":":cldk-link-16: Integration","text":"<p>Integration technologies featuring Jakarta Batch processing, JMS messaging patterns, message-driven beans, JAX-WS web services, and Java Connector Architecture for enterprise system integration.</p>"},{"location":"integration/#examples","title":"Examples","text":"<ul> <li>batch-phonebilling - Jakarta Batch API with ItemReader, ItemProcessor, ItemWriter, and chunk-oriented processing</li> <li>batch-webserverlog - Jakarta Batch with custom partitioning, checkpointing, and job orchestration</li> <li>connectors-trading - Java Connector Architecture resource adapter for EIS integration</li> <li>connectors-traffic - JCA inbound resource adapter with MessageEndpoint and WorkManager for async messaging</li> <li>jaxws-hello-appclient - JAX-WS web service client using <code>@WebServiceRef</code> in application client container</li> <li>jaxws-hello-webclient - JAX-WS web service client invocation from servlet using Service API</li> <li>jms-clientmdbentity - Message-driven beans with JPA entity persistence and JMS topics</li> <li>jms-clientsessionmdb - Message-driven bean consuming messages from stateless session bean</li> <li>jms-durablesubscription - Durable topic subscriptions with <code>@MessageDriven</code> and ActivationConfig properties</li> <li>jms-simple - JMS producer and consumer using <code>@Resource</code> injection for ConnectionFactory and Queue/Topic</li> <li>jms-simplemessage - Basic JMS message exchange with producer and consumer patterns</li> <li>jms-transactedexample - Transacted JMS sessions with message-driven beans and container-managed transactions</li> <li>jms-websimplemessage - JMS integration with web tier using managed beans for message sending/receiving</li> </ul>"},{"location":"persistence/","title":":cldk-database-16: Persistence","text":"<p>Data persistence patterns using JPA entities with CRUD operations, complex entity relationships, composite keys, inheritance strategies, and JPQL queries for database interactions.</p>"},{"location":"persistence/#examples","title":"Examples","text":"<ul> <li>address-book - JPA entities with JSF frontend using CRUD operations via EntityManager</li> <li>order - JPA entity relationships with composite keys and join tables</li> <li>roster - JPA inheritance strategies, JPQL queries, and many-to-many relationships</li> </ul>"},{"location":"petclinic/","title":"PetClinic","text":"<p>Full-featured veterinary clinic management system using Jakarta Faces (PrimeFaces) for the UI layer.</p>"},{"location":"petclinic/#overview","title":"Overview","text":"<p>PetClinic is a complete web application for managing a veterinary clinic. It demonstrates CRUD operations with complex entity relationships and provides comprehensive user workflows for managing owners, pets, visits, and veterinarians.</p>"},{"location":"petclinic/#key-technologies","title":"Key Technologies","text":"<ul> <li>Jakarta Faces (PrimeFaces) - Rich UI components</li> <li>JPA - Object-relational mapping</li> <li>CDI - Dependency injection</li> <li>Bean Validation - Input validation</li> <li>JSF Navigation - Page flow control</li> </ul>"},{"location":"petclinic/#architecture-highlights","title":"Architecture Highlights","text":"<ul> <li>One-to-many relationships (owners-pets)</li> <li>Many-to-one relationships (pets-visits)</li> <li>Many-to-many relationships (vets-specialties)</li> <li>Complex forms with validation</li> <li>Master-detail views</li> <li>CRUD operations for all entities</li> <li>Rich UI components (data tables, dialogs, forms)</li> <li>Complete user workflows for clinic operations</li> </ul>"},{"location":"presentation/","title":":cldk-browser-16: Presentation","text":"<p>Web tier implementations including servlets, JAX-RS REST APIs, WebSocket endpoints, server-sent events, file uploads, filters, listeners, and real-time communication patterns.</p>"},{"location":"presentation/#examples","title":"Examples","text":"<ul> <li>dukeetf - Async servlet with server-sent events for real-time updates</li> <li>dukeetf2 - WebSocket server endpoint for bidirectional real-time communication</li> <li>fileupload - Servlet file upload using <code>@MultipartConfig</code> for multipart/form-data handling</li> <li>hello-servlet - Basic HTTP servlet with request/response handling</li> <li>jaxrs-customer - JAX-RS REST API with CRUD operations, JPA entities, and client invocation</li> <li>jaxrs-hello - Simple JAX-RS resource with <code>@GET</code> and <code>@POST</code> methods</li> <li>jaxrs-rsvp - JAX-RS with JPA entities, <code>@Singleton</code>/<code>@Startup</code> lifecycle, and RESTful CRUD</li> <li>mood - Servlet filters and listeners for request/response processing and lifecycle events</li> <li>websocketbot - WebSocket encoders/decoders with session management for chat application</li> </ul>"},{"location":"quickstart/","title":"Quickstart Guide","text":"<p>This benchmark suite comes with most things needed to run the benchmark applications. Everything is already set up!</p>"},{"location":"quickstart/#whats-included","title":"What's Included","text":"<p>Each application comes with:</p> <ul> <li>Dockerfile - Pre-configured container with all dependencies installed</li> <li>justfile - Simple commands to build and run everything</li> <li>smoke.py or smoke/ - Automated tests to verify the application works</li> </ul> <p>You don't need to install Maven, Java, or any dependencies. Docker handles it all!</p>"},{"location":"quickstart/#prerequisites","title":"Prerequisites","text":"<p>You only need:</p> <ul> <li>Docker installed on your machine</li> <li>Just command runner (you can install it via Cargo or your package manager)</li> </ul>"},{"location":"quickstart/#running-an-application","title":"Running an Application","text":""},{"location":"quickstart/#step-1-pick-an-application","title":"Step 1: Pick an Application","text":"<p>Browse the directory structure and choose any application. For example:</p> <pre><code>business_domain/counter/spring/\ndependency_injection/encoder/jakarta/\npresentation/mood/quarkus/\n</code></pre>"},{"location":"quickstart/#step-2-navigate-to-the-application","title":"Step 2: Navigate to the Application","text":"<pre><code>cd business_domain/counter/spring\n</code></pre>"},{"location":"quickstart/#step-3-run-it","title":"Step 3: Run It!","text":"<pre><code>just up\n</code></pre> <p>That's it! The <code>just up</code> command will: 1. Build your application 2. Build the Docker container 3. Start everything up</p>"},{"location":"quickstart/#step-4-check-the-logs","title":"Step 4: Check the Logs","text":"<pre><code>just logs\n</code></pre>"},{"location":"quickstart/#step-5-stop-when-done","title":"Step 5: Stop When Done","text":"<pre><code>just down\n</code></pre>"},{"location":"quickstart/#common-commands","title":"Common Commands","text":"<p>Every application supports these commands (via the <code>justfile</code>):</p> Command What it does <code>just</code> Shows all available commands <code>just up</code> Builds and starts the application <code>just down</code> Stops the application <code>just logs</code> Shows application logs <code>just build</code> Builds the application (Maven) <code>just docker-build</code> Builds the Docker image <code>just clean</code> Removes build artifacts"},{"location":"quickstart/#running-smoke-tests","title":"Running Smoke Tests","text":"<p>Most applications include automated tests. To run them:</p> <pre><code># If smoke.py exists\npython3 smoke.py\n\n# If smoke/ folder exists\ncd smoke &amp;&amp; ./verify-all.sh\n</code></pre>"},{"location":"quickstart/#example-walkthrough","title":"Example Walkthrough","text":"<p>Let's run the counter application:</p> <pre><code># 1. Go to the application\ncd business_domain/counter/spring\n\n# 2. Start it up\njust up\n\n# 3. Wait a few seconds, then check logs\njust logs\n\n# 4. Open your browser to http://localhost:8080\n\n# 5. When done, stop it\njust down\n</code></pre>"},{"location":"quickstart/#framework-variations","title":"Framework Variations","text":"<p>Each application type comes in three flavors:</p> <ul> <li>jakarta/ - Jakarta EE (enterprise Java)</li> <li>quarkus/ - Quarkus (cloud-native Java)</li> <li>spring/ - Spring Boot (popular Java framework)</li> </ul> <p>Pick whichever framework you want to test!</p>"},{"location":"quickstart/#troubleshooting","title":"Troubleshooting","text":"<p>Port already in use? <pre><code>just down\n# Wait a few seconds\njust up\n</code></pre></p> <p>Want to rebuild from scratch? <pre><code>just clean\njust docker-build\njust up\n</code></pre></p> <p>Need to see what's happening? <pre><code>just logs\n</code></pre></p>"},{"location":"quickstart/#quick-reference","title":"Quick Reference","text":"<pre><code># See all commands\njust\n\n# Full workflow: build + start\njust up\n\n# Check if it's working\njust logs\n\n# Stop everything\njust down\n</code></pre>"},{"location":"realworld/","title":"RealWorld","text":"<p>Medium.com clone (Conduit) implementing the RealWorld specification with full CRUD operations, JWT authentication, article management, comments, favorites, tags, and user following.</p>"},{"location":"realworld/#overview","title":"Overview","text":"<p>RealWorld is a Medium.com clone that adheres to the RealWorld specification, providing a standardized way to build and compare fullstack applications. It includes comprehensive features for article publishing, user interactions, and social features.</p>"},{"location":"realworld/#key-technologies","title":"Key Technologies","text":"<ul> <li>MicroProfile JWT - Token-based authentication</li> <li>JAX-RS - RESTful API design</li> <li>JPA with PostgreSQL - Data persistence</li> <li>BCrypt - Password hashing</li> <li>Testcontainers - Integration testing</li> <li>MicroShed Testing - Testing framework</li> </ul>"},{"location":"realworld/#architecture-highlights","title":"Architecture Highlights","text":"<ul> <li>Complete RESTful API implementation</li> <li>JWT-based authentication and authorization</li> <li>Article CRUD with slug generation</li> <li>Comment system on articles</li> <li>User favorites and following</li> <li>Tag-based article categorization</li> <li>Pagination and filtering</li> <li>Comprehensive exception handling</li> <li>Integration tests with real database (Testcontainers)</li> <li>Secure password storage with BCrypt</li> </ul>"},{"location":"resources/","title":"Resources","text":"<p>[Placeholder: Resources content]</p>"},{"location":"security/","title":":cldk-shield-lock-16: Security","text":"<p>Authentication and authorization patterns featuring Jakarta Security identity stores, form-based and basic authentication, EJB security, role-based access control, and password hashing.</p>"},{"location":"security/#examples","title":"Examples","text":"<ul> <li>built-in-db-identity-store - Jakarta Security <code>@DatabaseIdentityStoreDefinition</code> with Pbkdf2PasswordHash</li> <li>custom-identity-store - Custom IdentityStore implementation with <code>@ApplicationScoped</code> CDI bean</li> <li>security-cart-secure - EJB security with <code>@DeclareRoles</code> and <code>@RolesAllowed</code> annotations</li> <li>security-converter-secure - Servlet-based security with declarative role-based access control</li> <li>security-hello1-formauth - Form-based authentication with <code>@FormAuthenticationMechanismDefinition</code></li> <li>security-hello2-basicauth - HTTP Basic authentication with <code>@BasicAuthenticationMechanismDefinition</code></li> </ul>"},{"location":"whole_applications/","title":"Whole Applications","text":"<p>Complete, production-grade application examples demonstrating the coordination and integration of multiple Java EE layers and technologies.</p>"},{"location":"whole_applications/#examples","title":"Examples","text":"<ul> <li> <p>cargotracker - Domain-Driven Design (DDD) cargo shipping tracker demonstrating Jakarta Faces, CDI, Enterprise Beans, JPA, REST, Batch, JSON Binding, Bean Validation, and JMS. Showcases end-to-end application architecture with multiple interfaces (web UI, REST API, file scanning) and complex domain modeling including aggregates, repositories, and domain events. Implements the cargo tracking example from Eric Evans' DDD book.</p> </li> <li> <p>coffee-shop - Microservices architecture with Orders, Barista, and Kitchen services communicating via Apache Kafka. Demonstrates MicroProfile (Config, Health, OpenAPI, Metrics), JPA with PostgreSQL, JAX-RS REST APIs, reactive messaging patterns, and distributed transaction coordination. Shows event-driven architecture with asynchronous inter-service communication and eventual consistency.</p> </li> <li> <p>daytrader - Online stock trading benchmark application demonstrating real-world Java EE workload patterns. Implements user authentication, portfolio management, stock quote lookup, and buy/sell transactions. Showcases performance-oriented design with stateless session beans, JPA entities with optimistic locking, transaction management, connection pooling, and web service interfaces. Used for measuring application server performance.</p> </li> <li> <p>petclinic - Full-featured veterinary clinic management system using Jakarta Faces (PrimeFaces) for the UI layer. Demonstrates CRUD operations with JPA entities showing one-to-many, many-to-one, and many-to-many relationships (owners-pets, pets-visits, vets-specialties). Includes CDI beans, Bean Validation, JSF navigation, complex forms, and master-detail views. Complete web application with user workflows for managing owners, pets, visits, and veterinarians.</p> </li> <li> <p>realworld - Medium.com clone (Conduit) implementing the RealWorld specification with full CRUD operations, JWT authentication, article management, comments, favorites, tags, and user following. Demonstrates MicroProfile JWT, JAX-RS REST API design, JPA with PostgreSQL, password hashing (BCrypt), slug generation, pagination, filtering, and comprehensive exception handling. Includes integration tests with Testcontainers and MicroShed testing framework.</p> </li> </ul>"},{"location":"core-concepts/","title":"Core Concepts","text":"<p>To be updated.</p>"},{"location":"reference/python-api/","title":"API Reference","text":""},{"location":"reference/python-api/#overview","title":"Overview","text":"<p>Browse the CLDK API reference. Use the links below to view package-specific documentation.</p>"},{"location":"reference/python-api/#core","title":"Core","text":"<p>Fundamental building blocks of CLDK. See the Core API.</p>"},{"location":"reference/python-api/#java","title":"Java","text":"<p>Program analysis for Java and related data models. See the Java API.</p>"},{"location":"reference/python-api/#python","title":"Python","text":"<p>Program analysis for Python and related data models. See the Python API.</p>"},{"location":"reference/python-api/#cc","title":"C/C++","text":"<p>Program analysis for C/C++ and related data models. See the C/C++ API.</p>"},{"location":"reference/python-api/c-cpp/","title":"C/C++ API","text":"<p>This page documents the C and C++ related APIs in the CLDK library.</p> <p>Use the table of contents to navigate classes, functions, and submodules exposed under the C/C++ analysis and schema packages.</p>"},{"location":"reference/python-api/c-cpp/#analysis","title":"Analysis","text":"<p>C/C++ analysis utilities and workflows.</p> <p>::: cldk.analysis.c.c_analysis</p>"},{"location":"reference/python-api/c-cpp/#schema","title":"Schema","text":"<p>Data models used by the C/C++ analyzers.</p> <p>::: cldk.models.c.models</p>"},{"location":"reference/python-api/core/","title":"Core API","text":"<p>::: cldk.core</p>"},{"location":"reference/python-api/java/","title":"Java API","text":""},{"location":"reference/python-api/java/#analysis","title":"Analysis","text":"<p>::: cldk.analysis.java.java_analysis</p>"},{"location":"reference/python-api/java/#schema","title":"Schema","text":"<p>::: cldk.models.java.models</p>"},{"location":"reference/python-api/python/","title":"Python API","text":"<p>This page documents the Python-related APIs in the CLDK library.</p> <p>Use the table of contents to navigate classes, functions, and submodules exposed under the Python analysis and schema packages.</p>"},{"location":"reference/python-api/python/#analysis","title":"Analysis","text":"<p>Python analysis utilities and workflows.</p> <p>::: cldk.analysis.python.python_analysis</p>"},{"location":"reference/python-api/python/#schema","title":"Schema","text":"<p>Data models used by the Python analyzers.</p> <p>::: cldk.models.python.models</p>"},{"location":"reference/ts-api/","title":"Typescript API Reference","text":""},{"location":"reference/ts-api/#overview","title":"Overview","text":"<p>Browse the CLDK's Typescript API reference. Use the links below to view package-specific documentation.</p> <p>(work in progress, please checkback later or email authors)</p>"}]}